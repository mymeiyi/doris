1. 功能设计概述

1.1 功能基本信息

- 功能名称：Batch Mode（批处理模式）
- 关联需求编号：
- 设计负责人：陈明雨
- 设计日期：2025-06-12
- 版本：V1.0
1.2 设计目标

- 优化Doris在读取数据时的split生成和分配机制，解决传统模式下的内存压力、分配不优和IO串行执行问题
- 通过异步生成split和按需分配的方式，提升整体查询效率，减少等待时间
- 实现动态负载均衡，让处理速度快的BE节点能够处理更多的split，减少水桶效应
- 降低FE的内存压力，避免一次性生成和保存所有split
- 提升系统的可扩展性和并发处理能力
2. 整体架构设计

2.1 架构示意图

Batch Mode采用FE和BE协同工作的架构模式：

┌─────────────────────────────────────────────────────────┐
│                      FE (Frontend)                       │
│  ┌───────────────────────────────────────────────────┐  │
│  │  Scan节点                                          │  │
│  │  ┌─────────────────────────────────────────────┐  │  │
│  │  │ 异步线程：边读取元数据，边生成split              │  │  │
│  │  └─────────────────────────────────────────────┘  │  │
│  │           ↓                                       │  │
│  │  ┌─────────────────────────────────────────────┐  │  │
│  │  │ SplitAssignment（split存储队列）              │  │  │
│  │  └─────────────────────────────────────────────┘  │  │
│  │           ↓                                       │  │
│  │  ┌─────────────────────────────────────────────┐  │  │
│  │  │ SplitService（响应BE请求，分发split）         │  │  │
│  │  └─────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                          ↕ (按需请求split)
┌─────────────────────────────────────────────────────────┐
│                    BE (Backend)                          │
│  ┌───────────────────────────────────────────────────┐  │
│  │ 主动向FE请求split                                  │  │
│  │  ┌─────────────────────────────────────────────┐  │  │
│  │  │ 获取一批split（batch_size）                   │  │  │
│  │  └─────────────────────────────────────────────┘  │  │
│  │           ↓                                       │  │
│  │  ┌─────────────────────────────────────────────┐  │  │
│  │  │ 并行读取数据                                   │  │  │
│  │  └─────────────────────────────────────────────┘  │  │
│  │           ↓                                       │  │
│  │  ┌─────────────────────────────────────────────┐  │  │
│  │  │ 读取完成后，再次请求新的split                  │  │  │
│  │  └─────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘

架构层次：

1. FE层（Frontend）：
- Scan节点：负责启动异步线程生成split
- SplitAssignment：存储生成的split队列
- SplitService：响应BE的split请求服务
2. BE层（Backend）：
- Split请求模块：主动向FE请求split
- 数据读取模块：根据获取的split进行数据读取
- 循环处理：读取完成后继续请求新的split
3. 存储层：
- 元数据存储（如Iceberg元数据）
- 数据文件存储（如HDFS）
3. 模块详细设计

3.1 模块划分

3.1.1 FE端模块

1. Split生成模块（Scan节点）
- 功能：以迭代方式读取元数据信息，异步生成split
- 职责：避免一次性读取所有元数据，减少内存压力和IO等待时间
2. Split存储模块（SplitAssignment）
- 功能：存储生成的split，作为FE和BE之间的缓冲区
- 职责：管理split队列，支持BE按需获取
3. Split分发服务（SplitService）
- 功能：响应BE的split请求，从SplitAssignment中获取split并发送给BE
- 职责：实现按需分配，不预先固定分配关系
3.1.2 BE端模块

1. Split请求模块
- 功能：主动向FE请求一批split
- 职责：管理client pool，处理请求超时和重试逻辑
2. 数据读取模块
- 功能：根据获取的split进行数据读取
- 职责：并行处理多个split，提升读取效率
3. 循环控制模块
- 功能：在split读取完成后，继续向FE请求新的split
- 职责：确保所有split都被处理完成
3.2 关键流程设计

3.2.1 Batch Mode数据查询流程

流程名称： Batch Mode数据查询流程

流程图： 
暂时无法在飞书文档外展示此内容

步骤说明：

1. 查询计划生成阶段：
- FE接收查询请求，开始生成查询计划
- 判断是否启用batch模式（根据num_partitions_in_batch_mode配置）
- 如果启用batch模式，进入异步split生成流程
2. 异步Split生成阶段：
- Scan节点启动异步线程
- 异步线程以迭代方式读取元数据信息（如Iceberg元数据文件）
- 边读取元数据，边生成split
- 将生成的split存入SplitAssignment队列
3. BE请求Split阶段：
- BE节点主动向FE的SplitService发送split请求
- 请求参数包括：请求的split数量（batch_size）、超时时间等
- FE的SplitService从SplitAssignment中获取可用的split
4. Split分发阶段：
- SplitService检查SplitAssignment中是否有可用的split
- 如果有，立即返回一批split给请求的BE
- 如果没有，等待异步线程生成split（最多等待fetch_splits_max_wait_time_ms时间）
5. 数据读取阶段：
- BE收到split后，立即开始并行读取数据
- 多个BE节点可以同时进行数据读取，实现并行IO
- FE的异步线程继续生成split，与BE的IO操作并行执行
6. 循环处理阶段：
- BE完成当前批次的split读取后，再次向FE请求新的split
- 重复步骤3-5，直到所有split都被处理完成
- 处理速度快的BE可以获取更多的split，实现动态负载均衡
7. 结果汇总阶段：
- 所有BE完成数据读取后，将结果返回给FE
- FE汇总所有结果，返回给客户端
3.2.2 传统模式 vs Batch Mode对比流程

传统模式流程：
1. FE一次性读取完所有元数据
2. FE生成所有split
3. FE预先分配split给固定的BE
4. FE统一发送split给BE
5. BE等待接收split后开始读取数据
Batch Mode流程：
1. FE启动异步线程，边读取元数据边生成split
2. BE主动请求split
3. FE有split就立即发送给BE
4. BE收到split后立即开始读取数据
5. BE读取完成后继续请求新的split
4. 数据模型设计

4.1 Split数据结构设计

Split是Batch Mode中的核心数据单元，包含以下信息：

// Split数据结构（伪代码）
class Split {
    // Split唯一标识
    String splitId;
    
    // 数据源信息
    String dataSourcePath;  // 数据文件路径
    
    // 读取范围
    long startOffset;       // 起始偏移量
    long length;            // 读取长度
    
    // 分区信息
    Map<String, String> partitionInfo;
    
    // 元数据信息
    Map<String, Object> metadata;
    
    // 状态信息
    SplitStatus status;     // PENDING, ASSIGNED, PROCESSING, COMPLETED
}

4.2 SplitAssignment数据结构

SplitAssignment是FE端存储split的队列结构：

// SplitAssignment数据结构（伪代码）
class SplitAssignment {
    // Split队列
    Queue<Split> pendingSplits;
    
    // 已分配的Split（用于跟踪）
    Set<String> assignedSplitIds;
    
    // 同步锁
    Lock lock;
    
    // 条件变量（用于BE等待split）
    Condition hasSplits;
}

4.3 数据关系图

查询请求
    ↓
Scan节点
    ↓
异步线程 → 读取元数据 → 生成Split → SplitAssignment队列
                                    ↓
                            SplitService ← BE请求
                                    ↓
                                返回Split
                                    ↓
                                BE读取数据

4.4 索引设计

- SplitAssignment使用队列（Queue）数据结构，支持FIFO（先进先出）的split分配策略
- 使用Set结构存储已分配的splitId，用于快速查找和去重
- 使用锁机制保证多线程环境下的数据一致性
5. 接口设计

5.1 外部接口

5.1.1 BE请求Split接口

* 接口端点： FE内部RPC接口（具体实现依赖Doris的RPC框架）

* 请求方法： RPC调用

* 输入参数：
- queryId (String, 必填) - 查询ID
- beNodeId (String, 必填) - BE节点ID
- batchSize (Integer, 可选) - 请求的split数量，默认值由remote_split_source_batch_size配置决定
- maxWaitTime (Long, 可选) - 最大等待时间（毫秒），默认值由fetch_splits_max_wait_time_ms配置决定
* 返回结果：
{
  "splits": [
    {
      "splitId": "split_001",
      "dataSourcePath": "hdfs://path/to/file",
      "startOffset": 0,
      "length": 1024,
      "partitionInfo": {...},
      "metadata": {...}
    }
  ],
  "hasMore": true,
  "totalSplits": 10000
}

* 异常处理：
- 如果FE重启导致连接失败，BE端会抛出异常，需要重新建立连接后重试
- 如果查询已结束，返回空split列表
5.2 内部接口

5.2.1 Split生成接口

* 类/方法名： `ScanNode.generateSplitsAsync()`

* 参数：
- metadataSource - 元数据源（如Iceberg元数据）
- splitAssignment - SplitAssignment实例，用于存储生成的split
* 返回值： `Future<Void>` - 异步执行结果

* 异常处理：
- IOException - 读取元数据时可能抛出
- InterruptedException - 线程中断异常
5.2.2 Split分发接口

* 类/方法名： `SplitService.getSplits()`

* 参数：
- queryId (String) - 查询ID
- beNodeId (String) - BE节点ID
- batchSize (Integer) - 请求的split数量
- maxWaitTime (Long) - 最大等待时间
* 返回值： `List<Split>` - 返回的split列表

* 异常处理：
- QueryNotFoundException - 查询不存在
- TimeoutException - 等待超时
- InterruptedException - 线程中断
5.2.3 SplitAssignment管理接口

* 类/方法名： `SplitAssignment.addSplit(Split split)`

* 参数： `split` - 要添加的split

* 返回值： `void`

* 异常处理： 无

* 类/方法名： `SplitAssignment.getSplits(int count, long timeoutMs)`

* 参数：
- count - 请求的split数量
- timeoutMs - 超时时间（毫秒）
* 返回值： `List<Split>` - 获取的split列表

* 异常处理：
- TimeoutException - 等待超时
- InterruptedException - 线程中断
6. 性能与安全设计

6.1 性能优化设计

6.1.1 内存优化

* Split流式生成：FE不再一次性生成所有split，而是边生成边分配，减少内存占用
* Split队列管理：使用队列结构，及时释放已分配的split，避免内存积累
* 缓存策略：BE端缓存client pool，减少连接建立开销

6.1.2 IO优化

* 并行IO：FE生成split的IO操作与BE读取数据的IO操作并行执行，提升整体吞吐量
* 异步处理：FE使用异步线程生成split，不阻塞主查询流程
* 批量请求：BE批量请求split（`remote_split_source_batch_size`），减少网络往返次数

6.1.3 负载均衡优化

* 动态分配：不再预先固定分配split给BE，而是根据BE的处理能力动态分配
* 减少水桶效应：处理速度快的BE可以获取更多split，避免慢节点拖累整体性能
* 按需分配：BE完成当前split后立即请求新的split，充分利用BE资源

6.1.4 查询优化

* 减少等待时间：BE不需要等待FE生成完所有split，可以提前开始数据读取
* 自适应切换：对于hive/hudi/mc catalog，根据分区数量自动切换batch模式

6.2 安全设计

6.2.1 权限控制

* 查询权限验证：FE在分发split前验证BE节点的查询权限
* 数据访问控制：Split中包含的数据路径信息需要符合访问控制策略

6.2.2 数据安全

* Split信息保护：Split在FE和BE之间传输时，确保传输通道的安全性
* 元数据安全：元数据读取操作需要遵循相应的安全策略

6.2.3 异常处理与容错

* FE重启容错：当FE重启时，BE端会检测到连接失败，通过重新建立连接和重试查询来恢复
* Split丢失防护：由于无法确定FE重启时split是否已分配，采用报错重试的保守策略，确保数据完整性
* 超时控制：设置合理的超时时间（`fetch_splits_max_wait_time_ms`），避免BE无限等待

6.2.4 审计日志

* Split分配日志：记录split的分配情况，包括分配时间、BE节点、split数量等
* 查询执行日志：记录batch模式查询的执行情况，用于性能分析和问题排查

7. 设计约束与限制

7.1 已知限制

1. FE重启容错限制：
- 当FE被重启时，batch模式下读取数据可能会出现报错
- 原因：无法确定在获取split时client失败的原因，无法确定split是否已经分配出去
- 解决方案：采用报错重试机制，重新建立连接后再次查询
2. Count(*)优化限制：
- 不能够对count(*)做最优化处理
- 后期会单独优化此功能
3. Iceberg Catalog限制：
- 针对iceberg catalog，现在只能手动开启batch模式
- 不能够自动从传统模式切换至batch模式
- 需要在mysql客户端手动设置：set num_partitions_in_batch_mode = 1025
4. Split数量较少时的负载不均：
- 当split个数较少时，可能会出现只有一个BE在处理split、其他BE没有split可处理的情况
- 这可能导致资源利用率不高
5. 存储集群压力：
- 由于FE的IO与BE的IO会出现并行的情况，可能会对存储集群（例如HDFS集群）造成一定的压力
- 需要根据存储集群的承载能力合理配置并发参数
7.2 假设条件

1. 网络稳定性：假设FE和BE之间的网络连接相对稳定，偶发的网络问题可以通过重试机制解决

2. 存储可用性：假设底层存储系统（如HDFS）能够支持FE和BE的并行IO访问

3. 元数据一致性：假设在查询执行期间，元数据信息保持相对稳定，不会出现大规模变更

4. BE节点可用性：假设BE节点在查询执行期间保持可用，不会频繁重启

7.3 技术债务

1. FE重启容错机制优化：
- 当前采用报错重试的保守策略
- 未来需要实现更精确的split状态跟踪，支持优雅的故障恢复
2. Count(*)优化：
- 需要单独设计和实现count(*)在batch模式下的优化方案
3. Iceberg自动切换：
- 需要实现iceberg catalog的自动batch模式切换逻辑，与hive/hudi/mc保持一致
4. 小split场景优化：
- 需要优化split数量较少时的负载分配策略，避免资源浪费
5. 存储压力监控：
- 需要增加对存储集群压力的监控和自适应调整机制
8. 附录

8.1 配置参数说明

8.1.1 FE端配置

* **`num_partitions_in_batch_mode`** (会话变量)
- 功能：控制是否启用batch模式的条件
- 默认值：根据catalog类型不同
- 说明：
  - 对于hive/hudi/mc：当查询分区个数大于等于此值时，自动使用batch模式
  - 对于iceberg：需要手动设置此值（如1025）来启用batch模式
8.1.2 BE端配置

* **`fetch_splits_max_wait_time_ms`** (BE配置)
- 功能：BE获取split的最大等待时间
- 默认值：1000（毫秒）
- 说明：当FE暂时没有可用split时，BE最多等待此时间
* **`remote_split_source_batch_size`** (BE配置)
- 功能：BE每次请求split的最大个数
- 默认值：1000
- 说明：BE每次向FE请求split时，最多请求此数量的split
8.2 使用示例

8.2.1 启用Iceberg Batch Mode

-- 在mysql客户端中设置
SET num_partitions_in_batch_mode = 1025;

-- 执行查询
SELECT * FROM iceberg_table WHERE partition_col = 'value';

8.2.2 Hive/Hudi/MC自动切换

-- 当查询的分区数 >= num_partitions_in_batch_mode 时，自动使用batch模式
-- 无需手动设置，系统自动判断
SELECT * FROM hive_table WHERE partition_col IN (...);

8.3 架构图

详细的架构流程图请参考：whiteboard_exported_image.png

8.4 相关文档

- Batch Mode设计文档：batch-mode设计文档.md
- Batch Mode提测文档：batch-mode提测文档.md