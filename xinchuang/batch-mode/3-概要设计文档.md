1. 文档基本信息
1.1 功能标识
- 功能名称：Batch Mode（批处理模式）
- 关联文档：
  - 需求文档：Batch-Mode 需求定义文档 V1.0
  - 概要设计文档：Batch-Mode 概要设计文档 V1.0
- 设计版本：V1.0
- 设计日期：2025-06-20
- 设计人员：陈明雨
2. 设计概述

2.1 设计范围

- 本次设计覆盖Batch Mode功能的完整实现，包括FE端和BE端的核心模块设计
- FE端设计范围：
  - Scan节点的异步split生成机制
  - SplitAssignment队列的存储和管理
  - SplitService的分发服务实现
- BE端设计范围：
  - Split请求模块的实现
  - 数据读取模块的集成
  - 循环控制模块的实现
- 支持的数据源：
  - Iceberg catalog（手动开启）
  - Hive catalog（自动切换）
  - Hudi catalog（自动切换）
  - MC catalog（自动切换）
- 不包括的内容：
  - Count(*)查询的优化（后期单独优化）
  - FE重启后的精确状态恢复机制（当前采用报错重试策略）
  - 存储集群压力的自动调节机制（需手动配置）
2.2 设计目标

- 技术实现目标：
  - 实现FE端异步生成split的机制，减少内存压力
  - 实现BE端主动请求split的机制，提升查询效率
  - 实现动态负载均衡，减少水桶效应
  - 实现FE和BE的并行IO，提升整体吞吐量
- 质量属性目标：
  - 性能：相比传统模式，大数据量查询响应时间降低30%-50%
  - 可靠性：支持FE重启后的错误恢复（通过重试机制）
  - 可维护性：模块职责清晰，接口设计合理，便于扩展和维护
  - 可扩展性：支持动态添加BE节点，支持更多catalog类型
3. 模块详细设计

3.1 模块结构

Batch Mode模块
├── FE端模块
│   ├── Scan节点模块
│   │   ├── ScanNode类
│   │   │   ├── generateSplitsAsync()方法
│   │   │   └── shouldUseBatchMode()方法
│   │   └── SplitGenerator类（异步线程）
│   │       ├── readMetadataIteratively()方法
│   │       └── generateSplitFromMetadata()方法
│   ├── Split存储模块
│   │   └── SplitAssignment类
│   │       ├── addSplit()方法
│   │       ├── getSplits()方法
│   │       ├── hasMoreSplits()方法
│   │       └── markSplitGenerationComplete()方法
│   └── Split分发服务模块
│       └── SplitService类
│           ├── getSplits()方法
│           ├── registerQuery()方法
│           └── unregisterQuery()方法
└── BE端模块
    ├── Split请求模块
    │   └── BESplitRequester类
    │       ├── requestSplits()方法
    │       ├── getClientPool()方法
    │       └── handleConnectionFailure()方法
    ├── 数据读取模块
    │   └── DataReader类
    │       ├── readDataFromSplit()方法
    │       └── processBatchSplits()方法
    └── 循环控制模块
        └── SplitLoopController类
            ├── startSplitLoop()方法
            ├── shouldContinueRequesting()方法
            └── onSplitBatchComplete()方法

3.2 类设计

3.2.1 类名：ScanNode

- 类职责：负责查询计划的Scan节点，判断是否启用batch模式，启动异步线程生成split
- 类关系：
  - 继承：继承Doris的ScanNode基类
  - 依赖：依赖SplitAssignment、SplitGenerator
  - 关联：与SplitService协作完成split分发
- 属性列表：
  - queryId (String) - 查询ID
  - splitAssignment (SplitAssignment) - Split存储队列
  - splitGenerator (SplitGenerator) - Split生成器
  - metadataSource (MetadataSource) - 元数据源
  - batchModeEnabled (boolean) - 是否启用batch模式
  - numPartitionsInBatchMode (int) - batch模式分区阈值
- 方法列表：
  - shouldUseBatchMode() - 判断是否应该使用batch模式
  - generateSplitsAsync() - 启动异步线程生成split
  - getSplitAssignment() - 获取SplitAssignment实例
  - onQueryComplete() - 查询完成时的清理工作
3.2.2 类名：SplitGenerator

- 类职责：异步线程类，负责迭代读取元数据并生成split
- 类关系：
  - 实现：实现Runnable接口
  - 依赖：依赖MetadataSource、SplitAssignment
  - 关联：由ScanNode启动和管理
- 属性列表：
  - metadataSource (MetadataSource) - 元数据源
  - splitAssignment (SplitAssignment) - Split存储队列
  - queryId (String) - 查询ID
  - running (AtomicBoolean) - 运行状态标志
  - exception (Exception) - 异常信息
- 方法列表：
  - run() - 异步线程主方法
  - readMetadataIteratively() - 迭代读取元数据
  - generateSplitFromMetadata() - 根据元数据生成split
  - stop() - 停止生成split
  - getException() - 获取异常信息
3.2.3 类名：SplitAssignment

- 类职责：存储和管理生成的split队列，提供线程安全的split添加和获取接口
- 类关系：
  - 依赖：依赖Split类
  - 关联：被SplitGenerator写入，被SplitService读取
- 属性列表：
  - pendingSplits (BlockingQueue<Split>) - 待分配的split队列
  - assignedSplitIds (ConcurrentHashMap<String, Boolean>) - 已分配的split ID集合
  - lock (ReentrantLock) - 同步锁
  - hasSplits (Condition) - 条件变量，用于通知等待的线程
  - splitGenerationComplete (AtomicBoolean) - split生成是否完成
  - totalSplitsGenerated (AtomicInteger) - 已生成的split总数
- 方法列表：
  - addSplit(Split split) - 添加split到队列
  - getSplits(int count, long timeoutMs) - 从队列获取指定数量的split
  - hasMoreSplits() - 判断是否还有更多split
  - markSplitGenerationComplete() - 标记split生成完成
  - getTotalSplitsGenerated() - 获取已生成的split总数
  - clear() - 清空队列
3.2.4 类名：SplitService

- 类职责：响应BE的split请求，从SplitAssignment中获取split并返回给BE
- 类关系：
  - 依赖：依赖SplitAssignment
  - 关联：与ScanNode协作，响应BE的RPC请求
- 属性列表：
  - querySplitAssignments (ConcurrentHashMap<String, SplitAssignment>) - 查询ID到SplitAssignment的映射
  - queryMetadata (ConcurrentHashMap<String, QueryMetadata>) - 查询元数据信息
  - lock (ReentrantLock) - 同步锁
- 方法列表：
  - registerQuery(String queryId, SplitAssignment splitAssignment) - 注册查询
  - unregisterQuery(String queryId) - 注销查询
  - getSplits(String queryId, String beNodeId, int batchSize, long maxWaitTime) - 获取split列表
  - isQueryActive(String queryId) - 判断查询是否活跃
3.2.5 类名：BESplitRequester

- 类职责：BE端主动向FE请求split，管理client pool，处理连接失败和重试
- 类关系：
  - 依赖：依赖FE的RPC客户端
  - 关联：与SplitLoopController协作
- 属性列表：
  - clientPool (Map<String, RpcClient>) - FE连接池
  - queryId (String) - 查询ID
  - beNodeId (String) - BE节点ID
  - batchSize (int) - 每次请求的split数量
  - maxWaitTime (long) - 最大等待时间
  - retryCount (int) - 重试次数
  - retryInterval (long) - 重试间隔
- 方法列表：
  - requestSplits() - 向FE请求split
  - getClientPool() - 获取或创建client pool
  - handleConnectionFailure(Exception e) - 处理连接失败
  - refreshClientPool() - 刷新client pool
3.2.6 类名：DataReader

- 类职责：根据获取的split进行数据读取，支持并行处理多个split
- 类关系：
  - 依赖：依赖Split类
  - 关联：被SplitLoopController调用
- 属性列表：
  - splits (List<Split>) - 待读取的split列表
  - threadPool (ExecutorService) - 线程池，用于并行读取
  - readResults (List<DataResult>) - 读取结果列表
- 方法列表：
  - readDataFromSplit(Split split) - 读取单个split的数据
  - processBatchSplits(List<Split> splits) - 并行处理一批split
  - getReadResults() - 获取读取结果
3.2.7 类名：SplitLoopController

- 类职责：控制BE端的split请求循环，在split读取完成后继续请求新的split
- 类关系：
  - 依赖：依赖BESplitRequester、DataReader
  - 组合：组合BESplitRequester和DataReader
- 属性列表：
  - splitRequester (BESplitRequester) - Split请求器
  - dataReader (DataReader) - 数据读取器
  - allSplitsProcessed (AtomicBoolean) - 是否所有split都已处理
  - running (AtomicBoolean) - 运行状态标志
- 方法列表：
  - startSplitLoop() - 启动split请求循环
  - shouldContinueRequesting() - 判断是否应该继续请求
  - onSplitBatchComplete() - 当一批split读取完成时的回调
  - stop() - 停止循环
3.3 关键方法详细设计

3.3.1 方法名：ScanNode.generateSplitsAsync()

- 功能描述：启动异步线程，以迭代方式读取元数据并生成split，将生成的split存入SplitAssignment队列
- 算法描述：
1. 判断是否应该使用batch模式（调用shouldUseBatchMode()）
2. 如果启用batch模式：
   a. 创建SplitAssignment实例
   b. 创建SplitGenerator实例，传入metadataSource和splitAssignment
   c. 启动异步线程执行SplitGenerator
   d. 在SplitService中注册当前查询
3. 如果未启用batch模式：
   a. 使用传统方式一次性生成所有split

- 输入参数：
  - 无（使用类的属性metadataSource等）
- 返回值：
  - Future<Void> - 异步执行结果，可用于等待split生成完成
- 异常处理：
  - IOException - 读取元数据时可能抛出，需要记录日志并向上抛出
  - InterruptedException - 线程中断异常，需要恢复中断状态
- 性能考虑：
  - 时间复杂度：O(n)，n为元数据文件数量，但通过迭代方式避免一次性加载
  - 空间复杂度：O(m)，m为队列中同时存在的split数量，远小于总split数
3.3.2 方法名：SplitGenerator.run()

- 功能描述：异步线程主方法，迭代读取元数据文件，生成split并存入SplitAssignment
- 算法描述：
1. 设置running = true
2. 循环读取元数据：
   a. 从metadataSource获取下一个元数据文件
   b. 解析元数据文件，提取数据文件信息
   c. 为每个数据文件生成一个或多个split
   d. 调用splitAssignment.addSplit()将split加入队列
   e. 如果元数据读取完成，跳出循环
3. 调用splitAssignment.markSplitGenerationComplete()
4. 设置running = false
5. 如果发生异常，记录异常信息

- 输入参数：
  - 无（使用类的属性）
- 返回值：
  - void
- 异常处理：
  - IOException - 读取元数据失败，记录异常并设置exception属性
  - InterruptedException - 线程中断，恢复中断状态并退出
- 性能考虑：
  - 时间复杂度：O(n * m)，n为元数据文件数，m为每个文件生成的split数
  - 空间复杂度：O(1)，不额外占用空间，split存入队列后即可释放
3.3.3 方法名：SplitAssignment.getSplits(int count, long timeoutMs)

- 功能描述：从队列中获取指定数量的split，如果没有足够的split则等待，最多等待timeoutMs毫秒
- 算法描述：
1. 获取锁
2. 循环直到获取到足够的split或超时：
   a. 检查队列中是否有足够的split
   b. 如果有，从队列中取出count个split
   c. 将取出的split的ID加入assignedSplitIds
   d. 返回split列表
   e. 如果没有足够的split：
      - 如果split生成已完成且队列为空，返回已获取的split（可能少于count）
      - 否则，等待hasSplits条件（最多等待timeoutMs）
3. 如果超时，返回已获取的split（可能少于count或为空）
4. 释放锁

- 输入参数：
  - count (int) - 请求的split数量
  - timeoutMs (long) - 超时时间（毫秒）
- 返回值：
  - List<Split> - 获取的split列表，可能少于count个
- 异常处理：
  - TimeoutException - 等待超时，返回已获取的split
  - InterruptedException - 线程中断，恢复中断状态并抛出
- 性能考虑：
  - 时间复杂度：O(count)，需要从队列中取出count个元素
  - 空间复杂度：O(count)，返回的列表占用空间
3.3.4 方法名：SplitService.getSplits(String queryId, String beNodeId, int batchSize, long maxWaitTime)

- 功能描述：响应BE的split请求，从对应查询的SplitAssignment中获取split并返回
- 算法描述：
1. 根据queryId查找对应的SplitAssignment
2. 如果查询不存在，抛出QueryNotFoundException
3. 如果查询已结束，返回空列表
4. 调用splitAssignment.getSplits(batchSize, maxWaitTime)获取split
5. 记录日志：分配时间、BE节点、split数量等
6. 返回split列表

- 输入参数：
  - queryId (String) - 查询ID
  - beNodeId (String) - BE节点ID
  - batchSize (int) - 请求的split数量
  - maxWaitTime (long) - 最大等待时间（毫秒）
- 返回值：
  - List<Split> - 返回的split列表
- 异常处理：
  - QueryNotFoundException - 查询不存在，需要记录日志
  - TimeoutException - 等待超时，返回已获取的split（可能为空）
  - InterruptedException - 线程中断，恢复中断状态并抛出
- 性能考虑：
  - 时间复杂度：O(1)查找 + O(batchSize)获取split
  - 空间复杂度：O(batchSize)，返回的列表占用空间
3.3.5 方法名：BESplitRequester.requestSplits()

- 功能描述：BE端主动向FE请求split，处理连接失败和重试逻辑
- 算法描述：
1. 获取或创建FE的RPC客户端（从clientPool）
2. 构建请求参数：queryId, beNodeId, batchSize, maxWaitTime
3. 尝试调用FE的SplitService.getSplits() RPC方法
4. 如果成功，返回split列表
5. 如果失败（连接异常）：
   a. 调用handleConnectionFailure()处理
   b. 刷新clientPool
   c. 重试（最多retryCount次）
6. 如果重试后仍失败，抛出异常

- 输入参数：
  - 无（使用类的属性）
- 返回值：
  - List<Split> - 从FE获取的split列表
- 异常处理：
  - ConnectionException - FE连接失败（可能是FE重启导致），需要刷新clientPool并重试
  - TimeoutException - 请求超时，可以重试
  - QueryNotFoundException - 查询不存在，需要停止请求
- 性能考虑：
  - 时间复杂度：O(1) RPC调用，但可能涉及网络延迟
  - 空间复杂度：O(batchSize)，返回的列表占用空间
3.3.6 方法名：SplitLoopController.startSplitLoop()

- 功能描述：启动BE端的split请求循环，持续请求split并读取数据，直到所有split处理完成
- 算法描述：
1. 设置running = true, allSplitsProcessed = false
2. 循环直到allSplitsProcessed为true：
   a. 调用splitRequester.requestSplits()请求一批split
   b. 如果返回的split列表为空：
      - 检查是否所有split都已处理（通过FE返回的hasMore标志）
      - 如果是，设置allSplitsProcessed = true，跳出循环
      - 否则，等待一段时间后继续请求
   c. 如果返回的split列表不为空：
      - 调用dataReader.processBatchSplits()并行读取数据
      - 等待读取完成
      - 调用onSplitBatchComplete()处理完成回调
3. 设置running = false

- 输入参数：
  - 无（使用类的属性）
- 返回值：
  - void
- 异常处理：
  - ConnectionException - FE连接失败，记录日志并抛出，由上层处理
  - InterruptedException - 线程中断，恢复中断状态并退出循环
- 性能考虑：
  - 时间复杂度：O(n/batchSize)次循环，n为总split数
  - 空间复杂度：O(batchSize)，同时处理的split数量
4. 接口详细设计

4.1 API接口

4.1.1 接口名称：BE请求Split接口

- 请求方式：RPC调用（基于Doris内部RPC框架）
- URL路径：FE内部RPC端点（具体路径依赖Doris RPC框架实现）
- 请求头：
  - queryId - 查询ID
  - beNodeId - BE节点ID
  - rpcTimeout - RPC超时时间
- 请求参数：
  - Query参数：无
  - Path参数：无
  - Body参数：
{
  "queryId": "query_123456",
  "beNodeId": "be_node_001",
  "batchSize": 1000,
  "maxWaitTime": 1000
}
- 响应格式：
  {
    "code": 0,
    "message": "success",
    "data": {
      "splits": [
        {
          "splitId": "split_001",
          "dataSourcePath": "hdfs://namenode:9000/data/file1.parquet",
          "startOffset": 0,
          "length": 1048576,
          "partitionInfo": {
            "partition_col": "2024-01-01"
          },
          "metadata": {
            "fileFormat": "parquet",
            "schema": "..."
          }
        }
      ],
      "hasMore": true,
      "totalSplits": 10000
    }
  }
- 错误码定义：
  - 0 - 成功
  - 1001 - 查询不存在（QueryNotFoundException）
  - 1002 - 等待超时（TimeoutException）
  - 1003 - 查询已结束
  - 1004 - 参数错误
  - 1005 - 内部错误
- 示例请求/响应：
  - 请求示例：
{
  "queryId": "query_123456",
  "beNodeId": "be_node_001",
  "batchSize": 1000,
  "maxWaitTime": 1000
}
  - 响应示例（成功）：
{
  "code": 0,
  "message": "success",
  "data": {
    "splits": [...],
    "hasMore": true,
    "totalSplits": 10000
  }
}
  - 响应示例（查询不存在）：
{
  "code": 1001,
  "message": "Query not found: query_123456",
  "data": null
}
4.1.2 接口名称：查询注册接口（内部接口）

- 请求方式：内部方法调用
- URL路径：N/A（内部接口）
- 请求头：N/A
- 请求参数：
  - queryId (String) - 查询ID
  - splitAssignment (SplitAssignment) - SplitAssignment实例
- 响应格式：void
- 错误码定义：N/A（抛出异常）
- 示例请求/响应：N/A（内部接口）
4.2 内部接口

4.2.1 服务接口

- 接口名称：SplitService.getSplits()
- 方法签名：
public List<Split> getSplits(String queryId, String beNodeId, 
                              int batchSize, long maxWaitTime) 
    throws QueryNotFoundException, TimeoutException, InterruptedException
- 参数说明：
  - queryId (String, 必填) - 查询的唯一标识符，用于查找对应的SplitAssignment
  - beNodeId (String, 必填) - BE节点的唯一标识符，用于日志记录和监控
  - batchSize (int, 必填) - 请求的split数量，通常由BE端配置remote_split_source_batch_size决定
  - maxWaitTime (long, 必填) - 最大等待时间（毫秒），如果队列中没有足够的split，最多等待此时间，通常由BE端配置fetch_splits_max_wait_time_ms决定
- 返回值说明：
  - List<Split> - 返回的split列表，可能少于batchSize个（如果split生成已完成且队列中不足batchSize个）
  - Split对象包含：splitId、dataSourcePath、startOffset、length、partitionInfo、metadata等信息
- 依赖服务：
  - SplitAssignment - 从队列中获取split
  - 查询元数据服务 - 验证查询是否存在和活跃
4.2.2 服务接口

- 接口名称：SplitAssignment.getSplits()
- 方法签名：
public List<Split> getSplits(int count, long timeoutMs) 
    throws TimeoutException, InterruptedException
- 参数说明：
  - count (int, 必填) - 请求的split数量
  - timeoutMs (long, 必填) - 超时时间（毫秒），如果队列中没有足够的split，最多等待此时间
- 返回值说明：
  - List<Split> - 获取的split列表，可能少于count个（如果超时或split生成已完成）
- 依赖服务：无（内部实现）
4.2.3 服务接口

- 接口名称：SplitAssignment.addSplit()
- 方法签名：
public void addSplit(Split split)
- 参数说明：
  - split (Split, 必填) - 要添加的split对象
- 返回值说明：
  - void
- 依赖服务：无（内部实现）
4.2.4 服务接口

- 接口名称：BESplitRequester.requestSplits()
- 方法签名：
public List<Split> requestSplits() 
    throws ConnectionException, TimeoutException, QueryNotFoundException
- 参数说明：
  - 无（使用类的属性：queryId、beNodeId、batchSize、maxWaitTime）
- 返回值说明：
  - List<Split> - 从FE获取的split列表
- 依赖服务：
  - FE的RPC服务 - 通过RPC调用FE的SplitService.getSplits()方法
  - Client Pool管理 - 管理FE连接池
5. 配置设计

5.1 配置文件

5.1.1 文件：FE端会话变量配置

- 文件格式：会话变量（Session Variable）
- 配置项：
  - num_partitions_in_batch_mode (int)
    - 功能：控制是否启用batch模式的条件
    - 默认值：根据catalog类型不同
    - 说明：
      - 对于hive/hudi/mc：当查询分区个数大于等于此值时，自动使用batch模式
      - 对于iceberg：需要手动设置此值（如1025）来启用batch模式
    - 取值范围：>= 0
    - 示例：SET num_partitions_in_batch_mode = 1025;
- 热更新支持：是（会话级别，立即生效）
5.1.2 文件：BE端配置文件（fe.conf或be.conf）

- 文件格式：Properties/YAML（根据Doris配置格式）
- 配置项：
  - fetch_splits_max_wait_time_ms (long)
    - 功能：BE获取split的最大等待时间
    - 默认值：1000（毫秒）
    - 说明：当FE暂时没有可用split时，BE最多等待此时间
    - 取值范围：> 0
    - 单位：毫秒
  - remote_split_source_batch_size (int)
    - 功能：BE每次请求split的最大个数
    - 默认值：1000
    - 说明：BE每次向FE请求split时，最多请求此数量的split
    - 取值范围：> 0
    - 建议值：根据BE内存和网络带宽调整，通常100-5000之间
- 热更新支持：否（需要重启BE节点）
5.1.3 文件：FE端系统配置（fe.conf）

- 文件格式：Properties/YAML（根据Doris配置格式）
- 配置项：
  - split_assignment_queue_size (int, 可选)
    - 功能：SplitAssignment队列的最大容量
    - 默认值：10000
    - 说明：限制队列中同时存在的split数量，防止内存溢出
    - 取值范围：> 0
  - split_generation_thread_pool_size (int, 可选)
    - 功能：Split生成线程池大小
    - 默认值：CPU核心数
    - 说明：控制同时进行split生成的线程数
    - 取值范围：> 0
- 热更新支持：否（需要重启FE节点）
6. 错误处理设计

6.1 错误分类

* 系统级错误：
- FE重启错误：当FE被重启时，BE端的client连接失败
- 网络错误：FE和BE之间的网络连接中断或超时
- 存储错误：元数据文件或数据文件读取失败
* 业务级错误：
- 查询不存在：BE请求的queryId对应的查询已结束或不存在
- Split生成失败：元数据读取或split生成过程中出现错误
- 超时错误：BE等待split超时或FE处理请求超时
- 参数错误：请求参数不合法
* 数据级错误：
- Split丢失：FE重启时无法确定split是否已分配
- 数据不一致：split分配状态与实际读取状态不一致
6.2 错误处理机制

- 重试机制：
  * BE端重试策略：
    * 当遇到连接失败（ConnectionException）时，自动刷新clientPool并重试
    * 重试次数：可配置（默认3次）
    * 重试间隔：指数退避策略（1s, 2s, 4s）
    * 如果重试后仍失败，抛出异常，由上层处理
  * FE端重试策略：
    * 元数据读取失败时，记录日志但不重试（由异步线程处理）
    * Split生成失败时，记录异常信息，查询会失败

- 降级方案：
  * 自动降级：
    * 当batch模式出现不可恢复的错误时，可以回退到传统模式
    * 对于不支持batch模式的场景，自动使用传统模式
  * 手动降级：
    * 用户可以通过设置num_partitions_in_batch_mode为0来禁用batch模式
    * 系统管理员可以通过配置禁用batch模式功能

- 报警机制：
  * 报警条件：
    * FE重启事件：记录FE重启日志，BE检测到连接失败时记录报警
    * Split生成失败：记录异常日志，触发报警
    * 查询超时：记录超时日志，触发报警
    * 连接失败频率过高：统计连接失败次数，超过阈值时触发报警
  * 报警方式：
    * 日志记录：记录ERROR级别日志，包含错误详情、时间戳、queryId等
    * 监控指标：记录错误计数、错误率等指标，便于监控系统告警
    * 用户提示：当FE重启导致查询失败时，返回明确的错误信息，提示用户重新查询

- 错误恢复：
  * FE重启恢复：
    * 当FE重启时，BE检测到连接失败
    * 由于无法确定split是否已分配，采用保守策略：报错并提示用户重新查询
    * 用户重新查询时，client会被刷新成正确的连接，数据能够被正确查询
  * 网络异常恢复：
    * BE端自动重试，刷新连接
    * 如果重试成功，继续处理查询
    * 如果重试失败，查询失败，用户需要重新提交查询

7. 部署与运维设计

7.1 监控指标

* FE端监控指标：
- batch_mode_queries_total - Batch模式查询总数
- batch_mode_splits_generated_total - 生成的split总数
- batch_mode_splits_pending - 当前队列中待分配的split数量
- batch_mode_split_generation_duration_ms - Split生成耗时（毫秒）
- batch_mode_split_service_request_total - SplitService请求总数
- batch_mode_split_service_request_duration_ms - SplitService请求处理耗时（毫秒）
- batch_mode_errors_total - 错误总数（按错误类型分类）
* BE端监控指标：
- batch_mode_split_requests_total - Split请求总数
- batch_mode_split_requests_duration_ms - Split请求耗时（毫秒）
- batch_mode_splits_received_total - 接收到的split总数
- batch_mode_connection_failures_total - 连接失败次数
- batch_mode_retry_total - 重试次数
* 系统级监控指标：
- batch_mode_memory_usage_bytes - Batch模式内存使用量（字节）
- batch_mode_active_queries - 当前活跃的batch模式查询数
- batch_mode_throughput_splits_per_second - Split处理吞吐量（split/秒）
7.2 日志规范

- 日志级别：DEBUG/INFO/WARN/ERROR
- 日志格式：
[timestamp] [level] [thread] [class] [queryId] [beNodeId] message [key=value]*
2025-01-XX 10:30:45.123 INFO [SplitGenerator-Thread-1] [SplitGenerator] [query_123456] Started generating splits for query
2025-01-XX 10:30:45.456 INFO [SplitService] [SplitService] [query_123456] [be_node_001] Received split request, batchSize=1000
2025-01-XX 10:30:45.789 INFO [SplitService] [SplitService] [query_123456] [be_node_001] Returned 1000 splits, hasMore=true
2025-01-XX 10:30:46.012 ERROR [BESplitRequester] [BESplitRequester] [query_123456] Connection failed, refreshing client pool
- 关键日志点：
  * FE端：
    * INFO：查询启用batch模式、开始生成split、split生成完成、注册/注销查询
    * WARN：队列接近容量上限、等待split超时但查询未结束
    * ERROR：Split生成失败、元数据读取失败、查询不存在、内部错误
  * BE端：
    * INFO：开始请求split、成功获取split、完成一批split读取、开始下一批请求
    * WARN：获取的split数量少于请求数量、等待超时
    * ERROR：连接失败、查询不存在、请求超时、重试失败
  * 系统级：
    * INFO：Batch模式启用/禁用、配置变更
    * WARN：内存使用率过高、队列容量接近上限
    * ERROR：系统级错误、不可恢复的错误

- 日志采样：
  - 对于高频操作（如split请求），可以采样记录，避免日志过多
  - 采样率可配置（默认1%，即每100次请求记录1次）
  - 错误日志始终完整记录，不采样
- 日志轮转：
  - 按照Doris的日志轮转策略
  - 建议保留最近7天的日志
  - 错误日志单独保留，建议保留30天