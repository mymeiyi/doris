# 1. 文档基本信息

## 1.1 功能标识
- 功能名称：两阶段提交（Two-Phase Commit, 2PC）
- 功能编码：DORIS-TXN-2PC-001-DD
- 关联文档：
  - 需求文档：两阶段提交功能需求定义文档 V1.0
  - 概要设计文档：两阶段提交功能概要设计文档 V1.0
- 设计版本：V1.0
- 设计日期：2025-06-20
- 设计人员：陈明雨

# 2. 设计概述

## 2.1 设计范围

本次设计聚焦于 Doris 两阶段提交（2PC）机制的 FE 端实现，主要包括：

**设计范围：**
- Stream Load 2PC HTTP 接口设计与实现
- FE 端事务管理器（GlobalTransactionMgr / DatabaseTransactionMgr）的 2PC 支持
- Label 管理器（LabelManager）的去重机制
- 事务状态机（TransactionState）的设计与状态转换
- 2PC 协议的 Prepare / Commit / Abort 流程
- EditLog 持久化与高可用设计

**不包括的内容：**
- BE 端数据写入实现（DeltaWriter、TabletWriter、RowSet 等）
- 数据存储层的具体实现
- 查询引擎相关功能
- DDL 事务支持

## 2.2 设计目标

**技术实现目标：**
- 实现完整的两阶段提交协议，支持 PREPARE → COMMITTED → VISIBLE 状态流转
- 实现 Stream Load 2PC HTTP 接口，支持外部系统（如 Flink）协调事务
- 实现 Label 去重机制，保证 Exactly-Once 语义
- 支持通过 txn_id 或 label 两种方式标识事务

**质量属性目标：**
- 性能：2PC 接口响应时间毫秒级（P99 < 100ms）
- 可靠性：支持 FE 主从切换后事务状态恢复
- 可用性：支持超时自动回滚、异常状态清理
- 可维护性：模块职责清晰，接口设计符合 RESTful 规范

# 3. 模块详细设计

## 3.1 模块结构

```
两阶段提交模块（FE端）
├── HTTP接口层
│   ├── StreamLoadAction类
│   │   ├── executeWithoutPassword() - 处理Stream Load请求
│   │   └── handleStreamLoad2PC() - 处理2PC预提交
│   └── StreamLoad2PCAction类
│       ├── executeCommit() - 处理提交请求
│       └── executeAbort() - 处理回滚请求
├── 事务管理层
│   ├── GlobalTransactionMgr类
│   │   ├── beginTransaction() - 开始事务
│   │   ├── preCommitTransaction() - 预提交事务
│   │   ├── commitTransaction() - 提交事务
│   │   ├── abortTransaction() - 回滚事务
│   │   └── getTransactionState() - 获取事务状态
│   ├── DatabaseTransactionMgr类
│   │   ├── beginTransaction() - 数据库级事务开始
│   │   ├── preCommitTransaction() - 数据库级预提交
│   │   ├── commitTransaction() - 数据库级提交
│   │   └── abortTransaction() - 数据库级回滚
│   └── TransactionState类
│       ├── 事务元信息存储
│       ├── 状态转换方法
│       └── 序列化/反序列化
├── Label管理层
│   └── LabelManager类（内嵌于DatabaseTransactionMgr）
│       ├── addLabel() - 添加Label
│       ├── getLabelTxnId() - 通过Label获取事务ID
│       ├── removeLabel() - 删除Label
│       └── cleanExpiredLabels() - 清理过期Label
└── 持久化层
    └── EditLog
        ├── logInsertTransactionState() - 记录事务开始
        ├── logPreCommitTransactionState() - 记录预提交
        ├── logCommitTransactionState() - 记录提交
        └── logAbortTransactionState() - 记录回滚
```

## 3.2 类设计

### 3.2.1 类名：GlobalTransactionMgr

- **类职责**：全局事务管理器，负责跨数据库的事务协调，提供事务操作的统一入口
- **类关系**：
  - 组合：DatabaseTransactionMgr（每个数据库一个实例）
  - 依赖：Env（获取全局环境）、EditLog（持久化）
- **属性列表**：

| 属性名 | 类型 | 默认值 | 说明 | 约束 |
|--------|------|--------|------|------|
| idToDbTxnMgr | Map<Long, DatabaseTransactionMgr> | new HashMap<>() | 数据库ID到事务管理器映射 | 线程安全 |
| idGenerator | IdGenerator | - | 事务ID生成器 | 全局唯一 |

- **方法列表**：

| 方法签名 | 返回类型 | 说明 |
|----------|----------|------|
| beginTransaction(long dbId, List<Long> tableIdList, String label, TxnCoordinator coordinator, LoadJobSourceType sourceType, long timeoutSecond) | long | 开始新事务，返回txnId |
| preCommitTransaction(long dbId, long txnId, List<TabletCommitInfo> tabletCommitInfos, TxnCommitAttachment attachment) | void | 预提交事务（2PC第一阶段） |
| commitTransaction(long dbId, long txnId, List<TabletCommitInfo> tabletCommitInfos, TxnCommitAttachment attachment) | void | 提交事务（2PC第二阶段） |
| abortTransaction(long dbId, long txnId, String reason) | void | 回滚事务 |
| getTransactionState(long dbId, long txnId) | TransactionState | 获取事务状态 |
| getLabelTxnId(long dbId, String label) | Long | 通过Label获取事务ID |

### 3.2.2 类名：DatabaseTransactionMgr

- **类职责**：数据库级事务管理器，管理单个数据库内的所有事务
- **类关系**：
  - 被组合：GlobalTransactionMgr
  - 依赖：EditLog、PublishVersionDaemon
- **属性列表**：

| 属性名 | 类型 | 默认值 | 说明 | 约束 |
|--------|------|--------|------|------|
| dbId | long | - | 数据库ID | 不可变 |
| idToRunningTxn | Map<Long, TransactionState> | new HashMap<>() | 运行中事务映射 | 线程安全 |
| idToFinalStatusTxn | Map<Long, TransactionState> | new LinkedHashMap<>() | 已完成事务映射 | LRU淘汰 |
| labelToTxnId | Map<String, Long> | new HashMap<>() | Label到事务ID映射 | Label唯一性 |
| runningTxnNums | int | 0 | 运行中事务数量 | 不超过max_running_txn_num_per_db |
| lock | ReentrantReadWriteLock | - | 读写锁 | 保证线程安全 |

- **方法列表**：

| 方法签名 | 返回类型 | 说明 |
|----------|----------|------|
| beginTransaction(List<Long> tableIdList, String label, TxnCoordinator coordinator, LoadJobSourceType sourceType, long listenerId, long timeoutSecond) | long | 开始事务 |
| preCommitTransaction(long txnId, List<TabletCommitInfo> tabletCommitInfos, TxnCommitAttachment attachment) | void | 预提交 |
| commitTransaction(long txnId, List<TabletCommitInfo> tabletCommitInfos, TxnCommitAttachment attachment) | void | 提交 |
| abortTransaction(long txnId, String reason) | void | 回滚 |
| getTransactionState(long txnId) | TransactionState | 获取状态 |
| cleanExpiredLabels() | void | 清理过期Label |

### 3.2.3 类名：TransactionState

- **类职责**：表示一个事务的完整状态信息，包括元数据、状态、时间戳等
- **类关系**：
  - 枚举依赖：TransactionStatus
  - 接口实现：Writable（序列化）
- **属性列表**：

| 属性名 | 类型 | 默认值 | 说明 | 约束 |
|--------|------|--------|------|------|
| transactionId | long | - | 事务ID | 全局唯一 |
| label | String | - | 事务Label | 数据库内唯一 |
| dbId | long | - | 数据库ID | 必填 |
| tableIdList | List<Long> | - | 涉及的表ID列表 | 非空 |
| transactionStatus | TransactionStatus | PREPARE | 事务状态 | 枚举值 |
| sourceType | LoadJobSourceType | - | 事务来源类型 | 必填 |
| prepareTime | long | -1 | 准备时间戳 | 毫秒 |
| preCommitTime | long | -1 | 预提交时间戳 | 毫秒 |
| commitTime | long | -1 | 提交时间戳 | 毫秒 |
| finishTime | long | -1 | 完成时间戳 | 毫秒 |
| reason | String | "" | 失败/回滚原因 | 可空 |
| tabletCommitInfos | List<TabletCommitInfo> | - | Tablet提交信息 | 2PC必填 |
| txnCommitAttachment | TxnCommitAttachment | - | 提交附件信息 | 可空 |
| coordinator | TxnCoordinator | - | 事务协调者信息 | 必填 |

- **方法列表**：

| 方法签名 | 返回类型 | 说明 |
|----------|----------|------|
| getTransactionStatus() | TransactionStatus | 获取当前状态 |
| setTransactionStatus(TransactionStatus status) | void | 设置状态 |
| isRunning() | boolean | 判断是否运行中 |
| isPreCommitted() | boolean | 判断是否预提交状态 |
| isCommitted() | boolean | 判断是否已提交 |
| isVisible() | boolean | 判断是否可见 |
| write(DataOutput out) | void | 序列化 |
| readFields(DataInput in) | void | 反序列化 |

### 3.2.4 类名：TransactionStatus（枚举）

- **类职责**：定义事务状态枚举值和状态转换规则
- **枚举值**：

| 枚举值 | 值 | 说明 | 可转换到 |
|--------|-----|------|----------|
| PREPARE | 0 | 事务准备中（初始状态） | PRECOMMITTED, COMMITTED, ABORTED |
| PRECOMMITTED | 1 | 预提交完成（2PC第一阶段完成） | COMMITTED, ABORTED |
| COMMITTED | 2 | 提交完成（等待发布版本） | VISIBLE |
| VISIBLE | 3 | 数据可见（最终成功状态） | - |
| ABORTED | 4 | 已回滚（最终失败状态） | - |

- **状态转换图**：

```
                    ┌─────────────────────────┐
                    │                         │
                    ▼                         │
    ┌─────────┐   2PC    ┌──────────────┐    │
    │ PREPARE │ ──────► │ PRECOMMITTED │ ───┤
    └─────────┘          └──────────────┘    │
         │                      │             │
         │ 1PC                  │ commit      │ abort
         │                      ▼             │
         │               ┌───────────┐        │
         └──────────────►│ COMMITTED │        │
                         └───────────┘        │
                               │              │
                               │ publish      │
                               ▼              │
                         ┌─────────┐          │
                         │ VISIBLE │          │
                         └─────────┘          │
                                              │
                         ┌─────────┐          │
                         │ ABORTED │ ◄────────┘
                         └─────────┘
```

### 3.2.5 类名：StreamLoadAction

- **类职责**：处理 Stream Load HTTP 请求，支持普通模式和 2PC 模式
- **类关系**：
  - 继承：RestBaseAction
  - 依赖：GlobalTransactionMgr、StreamLoadExecutor
- **属性列表**：

| 属性名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| env | Env | - | 全局环境引用 |

- **方法列表**：

| 方法签名 | 返回类型 | 说明 |
|----------|----------|------|
| executeWithoutPassword(BaseRequest request, BaseResponse response) | void | 处理Stream Load请求 |
| parseHeaders(HttpServletRequest request) | StreamLoadParam | 解析HTTP头参数 |
| isTwoPhaseCommit(StreamLoadParam param) | boolean | 判断是否2PC模式 |

### 3.2.6 类名：StreamLoad2PCAction

- **类职责**：处理 Stream Load 2PC 的 Commit 和 Abort 请求
- **类关系**：
  - 继承：RestBaseAction
  - 依赖：GlobalTransactionMgr
- **属性列表**：

| 属性名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| env | Env | - | 全局环境引用 |

- **方法列表**：

| 方法签名 | 返回类型 | 说明 |
|----------|----------|------|
| executeWithoutPassword(BaseRequest request, BaseResponse response) | void | 处理2PC请求 |
| handleCommit(String db, String table, long txnId, String label) | TxnOpResult | 处理提交 |
| handleAbort(String db, String table, long txnId, String label) | TxnOpResult | 处理回滚 |

## 3.3 关键方法详细设计

### 3.3.1 方法名：DatabaseTransactionMgr.beginTransaction()

- **功能描述**：开始一个新的事务，分配事务ID，创建事务状态对象，注册Label
- **算法描述**：

```
输入: tableIdList, label, coordinator, sourceType, listenerId, timeoutSecond
输出: transactionId

1. 获取写锁
2. 检查运行中事务数量
   IF runningTxnNums >= max_running_txn_num_per_db THEN
       THROW RunningTxnExceedException
   END IF
3. 检查Label是否已存在
   existingTxnId = labelToTxnId.get(label)
   IF existingTxnId != null THEN
       existingState = getTransactionState(existingTxnId)
       IF existingState.isRunning() OR existingState.isCommitted() THEN
           THROW LabelAlreadyUsedException(existingState)
       END IF
   END IF
4. 生成新的事务ID
   txnId = idGenerator.getNextId()
5. 创建TransactionState对象
   state = new TransactionState(dbId, tableIdList, txnId, label, 
                                sourceType, coordinator, timeoutSecond)
   state.setTransactionStatus(PREPARE)
   state.setPrepareTime(System.currentTimeMillis())
6. 注册到映射表
   idToRunningTxn.put(txnId, state)
   labelToTxnId.put(label, txnId)
   runningTxnNums++
7. 持久化到EditLog
   editLog.logInsertTransactionState(state)
8. 释放写锁
9. RETURN txnId
```

- **输入参数**：

| 参数名 | 类型 | 是否必填 | 描述 | 校验规则 |
|--------|------|----------|------|----------|
| tableIdList | List<Long> | 是 | 涉及的表ID列表 | 非空，表必须存在 |
| label | String | 是 | 事务Label | 非空，长度≤128 |
| coordinator | TxnCoordinator | 是 | 协调者信息 | 非空 |
| sourceType | LoadJobSourceType | 是 | 来源类型 | 枚举值 |
| listenerId | long | 否 | 监听器ID | -1表示无 |
| timeoutSecond | long | 否 | 超时时间（秒） | 默认使用配置值 |

- **返回值**：

| 字段 | 类型 | 描述 |
|------|------|------|
| transactionId | long | 新分配的事务ID |

- **异常处理**：

| 异常类型 | 触发条件 | 处理方式 |
|----------|----------|----------|
| LabelAlreadyUsedException | Label已被使用且对应事务有效 | 返回已存在的事务信息 |
| RunningTxnExceedException | 运行中事务数超限 | 返回错误，客户端重试 |
| AnalysisException | 参数校验失败 | 返回详细错误信息 |
| BeginTransactionException | 其他开始事务失败 | 返回错误原因 |

- **性能考虑**：
  - 时间复杂度：O(1)，HashMap操作
  - 空间复杂度：O(1)，创建固定大小对象
  - 并发：写锁保护，避免竞态条件

### 3.3.2 方法名：DatabaseTransactionMgr.preCommitTransaction()

- **功能描述**：2PC第一阶段，将事务状态从PREPARE转换为PRECOMMITTED，记录Tablet提交信息
- **算法描述**：

```
输入: txnId, tabletCommitInfos, txnCommitAttachment
输出: void

1. 获取写锁
2. 获取事务状态
   state = idToRunningTxn.get(txnId)
   IF state == null THEN
       THROW TransactionNotFoundException
   END IF
3. 检查当前状态
   IF state.getTransactionStatus() != PREPARE THEN
       THROW TransactionStatusException("当前状态不允许预提交")
   END IF
4. 更新事务信息
   state.setTabletCommitInfos(tabletCommitInfos)
   state.setTxnCommitAttachment(txnCommitAttachment)
   state.setPreCommitTime(System.currentTimeMillis())
   state.setTransactionStatus(PRECOMMITTED)
5. 持久化到EditLog
   editLog.logPreCommitTransactionState(state)
6. 释放写锁
```

- **输入参数**：

| 参数名 | 类型 | 是否必填 | 描述 | 校验规则 |
|--------|------|----------|------|----------|
| txnId | long | 是 | 事务ID | 必须存在 |
| tabletCommitInfos | List<TabletCommitInfo> | 是 | Tablet提交信息 | 非空 |
| txnCommitAttachment | TxnCommitAttachment | 否 | 提交附件 | 可空 |

- **返回值**：void

- **异常处理**：

| 异常类型 | 触发条件 | 处理方式 |
|----------|----------|----------|
| TransactionNotFoundException | 事务不存在 | 返回错误 |
| TransactionStatusException | 状态不允许预提交 | 返回当前状态 |

- **性能考虑**：
  - 时间复杂度：O(1)
  - 主要开销：EditLog持久化（同步写入BDB JE）

### 3.3.3 方法名：DatabaseTransactionMgr.commitTransaction()

- **功能描述**：提交事务，支持从PREPARE或PRECOMMITTED状态提交，触发版本发布
- **算法描述**：

```
输入: txnId, tabletCommitInfos, txnCommitAttachment
输出: void

1. 获取写锁
2. 获取事务状态
   state = idToRunningTxn.get(txnId)
   IF state == null THEN
       # 检查是否已完成
       state = idToFinalStatusTxn.get(txnId)
       IF state != null AND state.isCommitted() THEN
           RETURN  # 幂等处理
       END IF
       THROW TransactionNotFoundException
   END IF
3. 检查当前状态
   status = state.getTransactionStatus()
   IF status != PREPARE AND status != PRECOMMITTED THEN
       THROW TransactionStatusException
   END IF
4. 更新事务信息
   IF status == PREPARE THEN
       # 非2PC模式，直接使用传入的tabletCommitInfos
       state.setTabletCommitInfos(tabletCommitInfos)
       state.setTxnCommitAttachment(txnCommitAttachment)
   END IF
   # PRECOMMITTED状态使用已保存的信息
   state.setCommitTime(System.currentTimeMillis())
   state.setTransactionStatus(COMMITTED)
5. 持久化到EditLog
   editLog.logCommitTransactionState(state)
6. 从运行中事务移除，添加到已完成事务
   idToRunningTxn.remove(txnId)
   idToFinalStatusTxn.put(txnId, state)
   runningTxnNums--
7. 释放写锁
8. 异步触发版本发布
   publishVersionDaemon.addTask(state)
```

- **输入参数**：

| 参数名 | 类型 | 是否必填 | 描述 | 校验规则 |
|--------|------|----------|------|----------|
| txnId | long | 是 | 事务ID | 必须存在 |
| tabletCommitInfos | List<TabletCommitInfo> | 条件必填 | Tablet提交信息 | 非2PC时必填 |
| txnCommitAttachment | TxnCommitAttachment | 否 | 提交附件 | 可空 |

- **返回值**：void

- **异常处理**：

| 异常类型 | 触发条件 | 处理方式 |
|----------|----------|----------|
| TransactionNotFoundException | 事务不存在 | 返回错误 |
| TransactionStatusException | 状态不允许提交 | 返回当前状态 |
| TransactionCommitFailedException | 提交过程失败 | 返回失败原因 |

- **性能考虑**：
  - 时间复杂度：O(1)
  - 版本发布异步执行，不阻塞提交响应

### 3.3.4 方法名：DatabaseTransactionMgr.abortTransaction()

- **功能描述**：回滚事务，支持从PREPARE或PRECOMMITTED状态回滚
- **算法描述**：

```
输入: txnId, reason
输出: void

1. 获取写锁
2. 获取事务状态
   state = idToRunningTxn.get(txnId)
   IF state == null THEN
       # 检查是否已完成
       finalState = idToFinalStatusTxn.get(txnId)
       IF finalState != null THEN
           IF finalState.isAborted() THEN
               RETURN  # 幂等处理
           ELSE IF finalState.isCommitted() OR finalState.isVisible() THEN
               THROW TransactionCommittedException
           END IF
       END IF
       THROW TransactionNotFoundException
   END IF
3. 检查当前状态
   status = state.getTransactionStatus()
   IF status == COMMITTED OR status == VISIBLE THEN
       THROW TransactionCommittedException("已提交的事务无法回滚")
   END IF
4. 更新事务状态
   state.setFinishTime(System.currentTimeMillis())
   state.setReason(reason)
   state.setTransactionStatus(ABORTED)
5. 持久化到EditLog
   editLog.logAbortTransactionState(state)
6. 从运行中事务移除，添加到已完成事务
   idToRunningTxn.remove(txnId)
   labelToTxnId.remove(state.getLabel())  # 可选：立即释放Label
   idToFinalStatusTxn.put(txnId, state)
   runningTxnNums--
7. 释放写锁
```

- **输入参数**：

| 参数名 | 类型 | 是否必填 | 描述 | 校验规则 |
|--------|------|----------|------|----------|
| txnId | long | 是 | 事务ID | 必须存在 |
| reason | String | 否 | 回滚原因 | 可空 |

- **返回值**：void

- **异常处理**：

| 异常类型 | 触发条件 | 处理方式 |
|----------|----------|----------|
| TransactionNotFoundException | 事务不存在 | 返回错误 |
| TransactionCommittedException | 事务已提交 | 返回错误 |

### 3.3.5 方法名：StreamLoad2PCAction.handleCommit()

- **功能描述**：处理 Stream Load 2PC 提交请求，支持通过 txnId 或 label 指定事务
- **算法描述**：

```
输入: db, table, txnId, label
输出: TxnOpResult

1. 参数校验
   IF txnId == null AND label == null THEN
       RETURN error("必须指定txn_id或label")
   END IF
2. 获取数据库ID
   database = catalog.getDbNullable(db)
   IF database == null THEN
       RETURN error("数据库不存在")
   END IF
   dbId = database.getId()
3. 确定事务ID
   IF txnId == null THEN
       txnId = globalTransactionMgr.getLabelTxnId(dbId, label)
       IF txnId == null THEN
           RETURN error("Label不存在")
       END IF
   END IF
4. 执行提交
   TRY
       globalTransactionMgr.commitTransaction(dbId, txnId, null, null)
       RETURN success("transaction [" + txnId + "] commit successfully")
   CATCH TransactionNotFoundException e
       RETURN error("事务不存在")
   CATCH TransactionCommitFailedException e
       RETURN error(e.getMessage())
   END TRY
```

- **输入参数**：

| 参数名 | 类型 | 是否必填 | 描述 |
|--------|------|----------|------|
| db | String | 是 | 数据库名 |
| table | String | 是 | 表名（用于路由） |
| txnId | Long | 二选一 | 事务ID |
| label | String | 二选一 | 事务Label |

- **返回值**：TxnOpResult

### 3.3.6 方法名：cleanExpiredLabels()

- **功能描述**：清理过期的Label，释放Label去重空间
- **算法描述**：

```
输入: 无
输出: void

1. 获取写锁
2. 获取当前时间
   now = System.currentTimeMillis()
   expireTime = now - label_keep_max_second * 1000
3. 遍历已完成事务
   FOR EACH entry IN idToFinalStatusTxn.entrySet()
       state = entry.getValue()
       IF state.getFinishTime() > 0 AND state.getFinishTime() < expireTime THEN
           # 检查Label数量是否超过阈值
           IF labelToTxnId.size() > label_num_threshold THEN
               labelToTxnId.remove(state.getLabel())
               LOG.info("清理过期Label: " + state.getLabel())
           END IF
       END IF
   END FOR
4. 释放写锁
```

# 4. 接口详细设计

## 4.1 API接口

### 4.1.1 接口名称：Stream Load 2PC 预提交（Prepare）

- **请求方式**：POST
- **URL路径**：`/api/{db}/{table}/_stream_load`
- **请求头**：

| 头字段 | 是否必须 | 示例值 | 说明 |
|--------|----------|--------|------|
| Authorization | 是 | Basic cm9vdDo= | Basic认证，base64(user:password) |
| two_phase_commit | 是 | true | 启用2PC模式 |
| label | 否 | my_label_001 | 用户自定义Label，不指定则自动生成UUID |
| format | 否 | json | 数据格式：csv/json |
| column_separator | 否 | , | CSV列分隔符 |
| columns | 否 | k1,k2,v1 | 列映射 |
| max_filter_ratio | 否 | 0.1 | 最大过滤比例 |
| timeout | 否 | 600 | 超时时间（秒） |

- **请求参数**：
  - Body：数据文件内容（支持CSV、JSON格式）

- **响应格式**：

```json
{
    "TxnId": 18036,
    "Label": "55c8ffc9-1c40-4d51-b75e-f2265b3602ef",
    "TwoPhaseCommit": "true",
    "Status": "Success",
    "Message": "OK",
    "NumberTotalRows": 100,
    "NumberLoadedRows": 100,
    "NumberFilteredRows": 0,
    "NumberUnselectedRows": 0,
    "LoadBytes": 1031,
    "LoadTimeMs": 77,
    "BeginTxnTimeMs": 1,
    "StreamLoadPutTimeMs": 1,
    "ReadDataTimeMs": 0,
    "WriteDataTimeMs": 58,
    "CommitAndPublishTimeMs": 0
}
```

- **响应字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| TxnId | long | 事务ID，用于后续commit/abort |
| Label | String | 事务Label |
| TwoPhaseCommit | String | "true"表示2PC模式 |
| Status | String | Success/Fail/Publish Timeout |
| Message | String | 详细信息 |
| NumberTotalRows | long | 总行数 |
| NumberLoadedRows | long | 成功加载行数 |
| NumberFilteredRows | long | 过滤行数 |
| LoadBytes | long | 加载字节数 |
| LoadTimeMs | long | 加载耗时（毫秒） |

- **错误码定义**：

| HTTP状态码 | 错误信息 | 说明 |
|------------|----------|------|
| 400 | Invalid parameter | 参数错误 |
| 401 | Unauthorized | 认证失败 |
| 403 | Access denied | 权限不足 |
| 404 | Database/Table not found | 库表不存在 |
| 500 | Internal server error | 服务器内部错误 |

- **示例请求/响应**：

```bash
# 请求
curl --location-trusted -u root:password \
    -H "two_phase_commit:true" \
    -H "label:my_2pc_label" \
    -H "format:csv" \
    -H "column_separator:," \
    -T data.csv \
    http://fe_host:8030/api/test_db/test_table/_stream_load

# 响应
{
    "TxnId": 18036,
    "Label": "my_2pc_label",
    "TwoPhaseCommit": "true",
    "Status": "Success",
    "Message": "OK",
    "NumberTotalRows": 1000,
    "NumberLoadedRows": 1000,
    "NumberFilteredRows": 0,
    "NumberUnselectedRows": 0,
    "LoadBytes": 45678,
    "LoadTimeMs": 156
}
```

### 4.1.2 接口名称：Stream Load 2PC 提交（Commit）

- **请求方式**：PUT
- **URL路径**：`/api/{db}/{table}/_stream_load_2pc`
- **请求头**：

| 头字段 | 是否必须 | 示例值 | 说明 |
|--------|----------|--------|------|
| Authorization | 是 | Basic cm9vdDo= | Basic认证 |
| txn_id | 二选一 | 18036 | 事务ID |
| label | 二选一 | my_2pc_label | 事务Label |
| txn_operation | 是 | commit | 操作类型：commit |

- **请求参数**：无Body

- **响应格式**：

```json
{
    "status": "Success",
    "msg": "transaction [18036] commit successfully."
}
```

- **错误码定义**：

| HTTP状态码 | status | 说明 |
|------------|--------|------|
| 200 | Success | 提交成功 |
| 200 | Fail | 提交失败，详见msg |
| 404 | Fail | 事务不存在 |
| 500 | Fail | 服务器错误 |

- **示例请求/响应**：

```bash
# 通过txn_id提交
curl -X PUT --location-trusted -u root:password \
    -H "txn_id:18036" \
    -H "txn_operation:commit" \
    http://fe_host:8030/api/test_db/test_table/_stream_load_2pc

# 响应
{
    "status": "Success",
    "msg": "transaction [18036] commit successfully."
}

# 通过label提交
curl -X PUT --location-trusted -u root:password \
    -H "label:my_2pc_label" \
    -H "txn_operation:commit" \
    http://fe_host:8030/api/test_db/test_table/_stream_load_2pc

# 响应
{
    "status": "Success",
    "msg": "label [my_2pc_label] commit successfully."
}
```

### 4.1.3 接口名称：Stream Load 2PC 回滚（Abort）

- **请求方式**：PUT
- **URL路径**：`/api/{db}/{table}/_stream_load_2pc`
- **请求头**：

| 头字段 | 是否必须 | 示例值 | 说明 |
|--------|----------|--------|------|
| Authorization | 是 | Basic cm9vdDo= | Basic认证 |
| txn_id | 二选一 | 18037 | 事务ID |
| label | 二选一 | my_2pc_label | 事务Label |
| txn_operation | 是 | abort | 操作类型：abort |

- **请求参数**：无Body

- **响应格式**：

```json
{
    "status": "Success",
    "msg": "transaction [18037] abort successfully."
}
```

- **示例请求/响应**：

```bash
# 通过txn_id回滚
curl -X PUT --location-trusted -u root:password \
    -H "txn_id:18037" \
    -H "txn_operation:abort" \
    http://fe_host:8030/api/test_db/test_table/_stream_load_2pc

# 响应
{
    "status": "Success",
    "msg": "transaction [18037] abort successfully."
}
```

### 4.1.4 接口名称：SQL BEGIN 事务开启

- **请求方式**：MySQL协议SQL命令
- **语法格式**：

```sql
BEGIN;
BEGIN WITH LABEL {user_label};
```

- **请求参数**：

| 参数 | 类型 | 是否必填 | 说明 |
|------|------|----------|------|
| label | String | 否 | 用户指定Label |

- **响应格式**：

```json
{
    "label": "txn_insert_xxx",
    "status": "PREPARE",
    "txnId": ""
}
```

- **示例**：

```sql
mysql> BEGIN WITH LABEL my_txn_label;
Query OK, 0 rows affected (0.01 sec)
{'label':'my_txn_label', 'status':'PREPARE', 'txnId':''}
```

### 4.1.5 接口名称：SQL COMMIT 事务提交

- **请求方式**：MySQL协议SQL命令
- **语法格式**：

```sql
COMMIT;
```

- **响应格式**：

```json
{
    "label": "txn_insert_xxx",
    "status": "VISIBLE",
    "txnId": "10013"
}
```

- **示例**：

```sql
mysql> COMMIT;
Query OK, 0 rows affected (1.02 sec)
{'label':'my_txn_label', 'status':'VISIBLE', 'txnId':'10013'}
```

### 4.1.6 接口名称：SQL ROLLBACK 事务回滚

- **请求方式**：MySQL协议SQL命令
- **语法格式**：

```sql
ROLLBACK;
```

- **响应格式**：

```
Query OK, 0 rows affected (0.01 sec)
```

## 4.2 内部接口

### 4.2.1 服务接口：GlobalTransactionMgr.beginTransaction

- **接口名称**：beginTransaction
- **方法签名**：

```java
public long beginTransaction(long dbId, List<Long> tableIdList, String label,
    TxnCoordinator coordinator, LoadJobSourceType sourceType, long timeoutSecond)
    throws AnalysisException, LabelAlreadyUsedException, 
           BeginTransactionException, DuplicatedRequestException
```

- **参数说明**：

| 参数 | 类型 | 说明 |
|------|------|------|
| dbId | long | 数据库ID |
| tableIdList | List<Long> | 涉及的表ID列表 |
| label | String | 事务Label |
| coordinator | TxnCoordinator | 事务协调者信息（IP、类型） |
| sourceType | LoadJobSourceType | 来源类型（FRONTEND、BACKEND_STREAMING等） |
| timeoutSecond | long | 超时时间（秒） |

- **返回值说明**：
  - long - 新分配的事务ID

- **依赖服务**：
  - EditLog - 持久化事务状态
  - IdGenerator - 生成事务ID

### 4.2.2 服务接口：GlobalTransactionMgr.commitTransaction

- **接口名称**：commitTransaction
- **方法签名**：

```java
public void commitTransaction(long dbId, long transactionId,
    List<TabletCommitInfo> tabletCommitInfos,
    TxnCommitAttachment txnCommitAttachment)
    throws UserException
```

- **参数说明**：

| 参数 | 类型 | 说明 |
|------|------|------|
| dbId | long | 数据库ID |
| transactionId | long | 事务ID |
| tabletCommitInfos | List<TabletCommitInfo> | Tablet提交信息列表 |
| txnCommitAttachment | TxnCommitAttachment | 提交附件（如Stream Load统计） |

- **返回值说明**：void

- **依赖服务**：
  - EditLog - 持久化提交状态
  - PublishVersionDaemon - 异步发布版本

### 4.2.3 服务接口：PublishVersionDaemon

- **接口名称**：publishVersion
- **功能说明**：异步发布事务版本，使数据对查询可见
- **触发条件**：事务状态变为COMMITTED后自动触发
- **处理流程**：

```
1. 从待发布队列获取COMMITTED状态的事务
2. 构造PublishVersionRequest
   - 事务ID
   - 分区版本信息列表
3. 向涉及的BE发送publish_version RPC
4. 收集响应，判断是否成功
   - 多数副本成功即认为发布成功
5. 更新事务状态为VISIBLE
6. 持久化状态变更
```

# 5. 配置设计

## 5.1 配置文件

### 5.1.1 文件：fe.conf

- **文件格式**：Properties
- **配置项**：

| 配置项 | 类型 | 默认值 | 说明 | 热更新 |
|--------|------|--------|------|--------|
| label_keep_max_second | long | 259200 (3天) | Label保留最大时间（秒） | 是 |
| label_num_threshold | int | 2000 | 触发Label淘汰的数量阈值 | 是 |
| max_running_txn_num_per_db | int | 1000 | 每个数据库最大运行中事务数 | 是 |
| streaming_label_keep_max_second | long | 43200 (12小时) | Stream Load Label保留时间 | 是 |
| transaction_clean_interval_second | int | 30 | 事务清理检查间隔（秒） | 否 |
| default_rowset_type | String | BETA | 默认RowSet类型 | 否 |

### 5.1.2 Session变量

- **配置项**：

| 配置项 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| insert_timeout | int | 3600 | INSERT超时时间（秒） |
| query_timeout | int | 300 | 查询超时时间（秒） |
| transaction_insert | boolean | true | 是否开启事务写入 |

- **设置方式**：

```sql
SET insert_timeout = 7200;
SET query_timeout = 600;
```

### 5.1.3 Stream Load 请求参数

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| two_phase_commit | boolean | false | 是否启用2PC |
| timeout | int | 600 | 请求超时时间（秒） |
| label | String | UUID | 事务Label |
| max_filter_ratio | double | 0 | 最大过滤比例 |

# 6. 错误处理设计

## 6.1 错误分类

| 错误类型 | 错误码范围 | 处理策略 | 日志级别 |
|----------|------------|----------|----------|
| 参数校验错误 | 1064 | 返回详细错误信息 | WARN |
| Label已存在 | 5025 | 返回已存在事务信息 | WARN |
| 事务不存在 | 5026 | 返回错误 | WARN |
| 提交失败 | 5027 | 返回失败原因 | ERROR |
| 超时错误 | 5028 | 自动回滚 | WARN |
| 状态错误 | 5029 | 返回当前状态 | WARN |
| 运行事务数超限 | 5030 | 返回错误，客户端重试 | WARN |
| 系统内部错误 | 5000 | 返回错误并记录日志 | ERROR |

## 6.2 错误处理机制

### 6.2.1 Label冲突处理

- **场景**：使用已存在的Label创建事务
- **处理逻辑**：

```
IF 已存在Label对应的事务 THEN
    IF 事务状态为 VISIBLE THEN
        返回 LabelAlreadyUsedException，包含事务ID和状态
        客户端应判断为重复请求，幂等成功
    ELSE IF 事务状态为 PREPARE/PRECOMMITTED THEN
        返回 LabelAlreadyUsedException，事务运行中
        客户端应等待或查询状态
    ELSE IF 事务状态为 ABORTED THEN
        Label已被释放（如果配置允许），可以重用
    END IF
END IF
```

### 6.2.2 超时处理

- **事务超时**：
  - 检测周期：transaction_clean_interval_second
  - 超时判断：当前时间 - prepareTime > timeout
  - 处理动作：自动回滚，状态设为ABORTED

- **2PC超时**：
  - PRECOMMITTED状态也会超时检查
  - 超时后自动回滚，释放资源

### 6.2.3 重试机制

| 场景 | 重试策略 | 说明 |
|------|----------|------|
| 网络超时 | 客户端重试，指数退避 | 1s, 2s, 4s |
| Label已存在(VISIBLE) | 不重试，视为成功 | 幂等性保证 |
| Label已存在(运行中) | 查询状态后决定 | 避免重复 |
| 运行事务数超限 | 延迟重试 | 等待其他事务完成 |

### 6.2.4 降级方案

- **FE主从切换**：
  - 事务状态通过BDB JE同步到Follower
  - 主切换后，新Master从EditLog恢复状态
  - 运行中事务可继续操作

- **版本发布失败**：
  - 事务状态保持COMMITTED
  - 定期重试发布
  - 不影响新事务

## 6.3 常见错误及解决方案

| 错误信息 | 原因 | 解决方案 |
|----------|------|----------|
| Label already used | Label重复 | 检查是否重复提交，使用新Label |
| Transaction not found | 事务已超时或不存在 | 重新开始事务 |
| Running txn exceeds limit | 运行事务数超限 | 等待或增加配置 |
| Transaction status error | 状态不允许当前操作 | 检查事务状态 |
| Commit failed | 提交过程出错 | 查看详细错误信息 |

# 7. 部署与运维设计

## 7.1 监控指标

| 指标名称 | 采集方式 | 报警阈值 | 处理建议 |
|----------|----------|----------|----------|
| doris_fe_txn_running_count | Prometheus | > 800 | 检查事务是否正常提交 |
| doris_fe_txn_precommitted_count | Prometheus | > 100 | 检查2PC commit是否执行 |
| doris_fe_txn_begin_latency_ms | Prometheus | P99 > 100ms | 检查FE负载 |
| doris_fe_txn_commit_latency_ms | Prometheus | P99 > 5000ms | 检查BE状态和网络 |
| doris_fe_txn_failed_count | Prometheus | > 10/min | 检查错误日志 |
| doris_fe_label_count | Prometheus | > 1800 | 检查Label淘汰 |
| doris_fe_publish_version_latency_ms | Prometheus | P99 > 3000ms | 检查BE响应 |

## 7.2 日志规范

- **日志级别**：DEBUG / INFO / WARN / ERROR
- **日志格式**：

```
[timestamp] [level] [thread] [class] [txnId=xxx] [label=xxx] message [key=value]*
```

- **关键日志点**：

| 操作 | 级别 | 日志内容 |
|------|------|----------|
| 事务开始 | INFO | `Begin transaction, txnId={}, label={}, tables={}` |
| 预提交 | INFO | `PreCommit transaction, txnId={}, tablets={}` |
| 提交成功 | INFO | `Commit transaction success, txnId={}, duration={}ms` |
| 提交失败 | ERROR | `Commit transaction failed, txnId={}, reason={}` |
| 回滚 | INFO | `Abort transaction, txnId={}, reason={}` |
| 超时回滚 | WARN | `Transaction timeout, txnId={}, label={}, elapsed={}s` |
| 版本发布 | INFO | `Publish version, txnId={}, version={}, tablets={}` |
| Label淘汰 | INFO | `Clean expired label, label={}, finishTime={}` |

- **日志示例**：

```
2025-06-20 10:30:45.123 INFO [TransactionMgr] [txnId=18036] [label=my_2pc_label] Begin transaction, tables=[10001, 10002]
2025-06-20 10:30:46.234 INFO [TransactionMgr] [txnId=18036] [label=my_2pc_label] PreCommit transaction, tablets=128
2025-06-20 10:31:00.456 INFO [TransactionMgr] [txnId=18036] [label=my_2pc_label] Commit transaction success, duration=15233ms
2025-06-20 10:31:01.567 INFO [PublishVersionDaemon] [txnId=18036] Publish version success, version=102, visibleTime=1111ms
```

## 7.3 运维操作

### 7.3.1 查看事务状态

```sql
-- 查看运行中事务
SHOW PROC '/transactions/{db_id}/running';

-- 查看已完成事务
SHOW PROC '/transactions/{db_id}/finished';

-- 通过Label查询
SHOW TRANSACTION WHERE LABEL = 'my_label';
```

### 7.3.2 手动清理

```sql
-- 清理指定Label（仅管理员）
ADMIN CLEAN LABEL FROM {db_name} WHERE LABEL = 'stuck_label';
```

### 7.3.3 配置热更新

```sql
-- 更新Label保留时间
ADMIN SET FRONTEND CONFIG ("label_keep_max_second" = "172800");

-- 更新最大运行事务数
ADMIN SET FRONTEND CONFIG ("max_running_txn_num_per_db" = "2000");
```

# 8. Flink 集成设计

## 8.1 Flink Doris Connector 2PC 支持

Flink Doris Connector 通过 2PC 机制实现 Exactly-Once Semantics (EOS)。

### 8.1.1 集成流程

```
Flink Checkpoint 触发
       │
       ▼
┌──────────────────┐
│ 1. snapshotState │  Flink调用，触发预提交
└──────────────────┘
       │
       ▼
┌──────────────────┐
│ 2. Stream Load   │  发送数据到Doris
│    2PC Prepare   │  Header: two_phase_commit=true
└──────────────────┘
       │
       ▼
┌──────────────────┐
│ 3. 保存txnId到   │  Flink State保存事务信息
│    Checkpoint    │
└──────────────────┘
       │
       ▼
┌──────────────────┐
│ 4. Checkpoint    │  Flink Checkpoint完成通知
│    Complete      │
└──────────────────┘
       │
       ▼
┌──────────────────┐
│ 5. Stream Load   │  发送commit请求
│    2PC Commit    │
└──────────────────┘
```

### 8.1.2 故障恢复

- **Checkpoint成功，Commit失败**：
  - Flink从Checkpoint恢复
  - 读取保存的txnId
  - 重新发送Commit请求（幂等）

- **Prepare成功，Checkpoint失败**：
  - 事务在Doris端超时回滚
  - Flink重新发送数据
  - 使用新Label

### 8.1.3 配置参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| sink.enable-2pc | true | 启用2PC |
| sink.buffer-flush.interval | 10s | 刷新间隔 |
| sink.buffer-flush.max-rows | 50000 | 最大缓存行数 |
| sink.max-retries | 3 | 最大重试次数 |
